#include "Sort2.h"

//! Функция сортировки
/** 
  Для решения задачи сортировки эти три этапа выглядят так:
Сортируемый массив разбивается на две части примерно одинакового размера;
Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
Два упорядоченных массива половинного размера соединяются в один.
1.1. - 2.1. Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер 
массива не достигнет единицы (любой массив длины 1 можно считать упорядоченным).
3.1. Соединение двух упорядоченных массивов в один.
Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере.
Пусть мы имеем два подмассива. Пусть также, элементы подмассивов в каждом из этих подмас-
сивов отсортированы по возрастанию. Тогда:
3.2. Слияние двух подмассивов в третий результирующий массив.
На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в 
результирующий массив. Счетчики номеров элементов результирующего массива и подмассива из
которого был взят элемент увеличиваем на 1.
3.3. "Прицепление" остатка.
Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмас-
сива в результирующий массив.
*/

void merge(int *a, int first, int last)
{
	int middle, start, final, j;
	int *mas=new int[last+2];
	middle=(first+last)/2;
	start=first;
	final=middle+1;
	for(j=first; j<=last; j++)
		if ((start<=middle) && ((final>last) || (a[start]<a[final])))
		{
			mas[j]=a[start];
			start++;
		}
		else
		{
			mas[j]=a[final];
			final++;
		}
		
		for (j=first; j<=last; j++) a[j]=mas[j];
		delete[]mas;
}



void sort2(int *a, int first, int last)
{
	{
		if (first<last)
		{
			sort2(a, first, (first+last)/2);
			sort2(a, (first+last)/2+1, last);
			merge(a, first, last);
		}
	}
}